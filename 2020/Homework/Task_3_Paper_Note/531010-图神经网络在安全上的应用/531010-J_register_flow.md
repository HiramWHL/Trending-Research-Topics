# 531010-图神经网络在安全领域内的应用

## 图神经网络简介
神经网络的主要作用在于如何将原始的输入数据转化为稠密向量，然后针对向量进行应用。一般的任务有如下3个。
1. **节点层面任务**
比如社交网络中用户标签的分类等,主要关注的是节点和边层面的特征。
2. **边层面任务**
最使人感兴趣的是将用户作为节点，用户之间的关系作为边，通过边预测实现用户推荐。这个层面的任务主要关注节点和边的特征。
3. **图层面的任务**
比如对化学分子的分类，主要考虑的是如何获得全图的信息。比如图的拓扑结构信息等。

## 图神经网络安全研究简介
目前使用图神经网络的研究安全领域的论文相比传统的深度学习方法以及机器学习方法还较少，主要研究内容也集中于社交网络和风控领域，因为这些领域有着网络的概念，网络本身就是一个图，可以很方便地应用图神经网络对这些问题进行分析，例如淘宝利用图神经网络对市场中的，恶意评价和假货商品进行识别。腾讯也有使用图神经网络对应用市场的用户进行分类。另一个领域在于检测网络中的异常状态等。<br>
聚焦于安全领域的图神经网络应用还有一部分集中于二进制，例如病毒代码识别，还有基于二进制代码相似度去统一不同编译器优化生成的代码。<br>

## 图神经网络进行漏洞检测
我认为我们可以利用图神经网络去发现可能存在的漏洞，最关键要讨论的问题是如何去构建图？而后续无论是在边层面上进行训练，例如进行预测任务，预测寄存器A在某个时刻（某个状态）下的数据在后续过程中达到eip的可能性。或是在图层面进行训练，进行分类任务，去判断一个crash是否是一个bug，减轻fuzz工具发现crash后验证的工作量，都是可以的。

### 困难点
1. 图神经网络研究目前集中于静态图，而程序运行是一个动态的过程，如何处理动态图是一个挑战。
2. 传统优秀的一些fuzz工具或者污点分析工具通常进行的是白盒测试，而在软件分析的黑盒测试场景中常会遇到代码中存在反编译对抗技术的情况，难以获得原始代码，也就无法使用这类工具。
3. 如何减小图训练时的工作量

### 如何构建一个程序图的思路
在二进制分析的论文中常用的图主要有控制流程图，语法分析树和数据流图等。但是由于我关注于黑盒的情况，因此类似控制流程和语法分析树比较难以构建，所以我认为可以针对寄存器绘制图。
#### 动态图问题
选取EAX，ECX，EBX，EDX，ESP，EBP，ESI，EDI，EIP，EFLAG这10个常见寄存器作为结点，结点之间的边代表数据从结点A流向结点B。
```
    ------ ------ ------ ... ------ ------
    | EAX| | EBX| | ECX| ... | EDX| | EIP|
    ------ ------ ------     ------ ------
```
为了解决动态图问题，我认为可以利用agenda机制，即我们将时间看作一个个时间片串联起来的链表，每当这个时间片内触发事件时，代表这个时间片结束，转进下一个时间片。在这个设想中，每个寄存器拥有自己的一个agenda链表，每个寄存器在自己的agenda上尽管处于不同的时间片，但在全局中他们时间是同步的。
```
x代表已经过的时间片，o代表当前时间片
时刻t=t0时，EAX的Agenda:
    --------------------------------------------------
    | x | x | x | x | o | <--- A目前的时间片
    --------------------------------------------------
时刻t=t0时，EBX的Agenda:
    --------------------------------------------------
    | x | x | o | <---- B目前的时间片
    --------------------------------------------------
```
约定每当触发事件时，当前时间片结束，转进下一个时间片，我们对应的在图上增加一个结点，和指向它的一条边，它是某个寄存器在这一时刻的代表。以EAX与ECX为例，初始过程中仅有eax0，ecx0两个结点。假设有一条语句mov eax, ecx，会在eax0与ecx0之间添加一条边对应生成的图如下
```
                o (eax0)  <--------- o (ecx0)
```
某个时刻触发了eax的agenda事件后，将会在图上新增一个结点代表eax，称为eax1，并连接eax0，eax1
```
                o (eax0)  <--------- o (ecx0)
                |
                v
                o (eax1)
```
若此时再次遇到一条mov eax，ecx的语句，则此时将会在ecx0与eax1之间进行连线，而不是ecx0与eax0之间，因为eax1代表着eax寄存器。
```
                o (eax0)  <--------- o (ecx0)
                |                    |
                v                    |
                o (eax1)  <-----------

```
那么如何规定agenda的触发事件呢，汇编中常见的数据形式如下。
- 堆栈内的数据
- 数据段内的数据
- 立即数
- 寄存器数据

约定当有外部数据进入寄存器时，视为一个**触发事件**，**外部数据**在这里指的是堆栈内数据和数据段内的数据，**内部数据**为立即数和只读数据段中的数据。其中寄存器数据其实比较特殊，其来源其实都是其他类型的数据，因此构建图的过程中可能需要一个数组，通过flag记录当前寄存器内是外部数据还是内部数据。<br>

针对if语句进行判断的形式，可能想到的就是类比子树生成，在图上分出2个分支，递归地处理(目前认为可以fork一个新进程继续这个分支的代码扫描,构建图)。
```
                            o (eax0)
                            |
            o (eax1) <-------------->  o(eax2)
```

#### 减少图的计算量
1. 如果针对一个程序构建完整的图，那么图中的结点和边数将十分巨大，给运算带来困难，此外，对内部调用的函数进行递归分析也是性能杀手，因此这种图构建方法的适用范围应该是单个函数，且默认不去分析系统调用函数以及标准库的函数，即默认这些函数是安全的，此外，这些函数通常遵守调用约定，函数进入和函数返回时寄存器的行为是有规则且可知的。
2. 我们还可以从某个触发事件开始分析，舍弃触发事件前的所有时间片，仅保留各个寄存器的最新状态，这样默认该时间点以前没有漏洞，不会触发数据污染，仅聚焦于后续的指令流。

## 参考
1. https://www.zybuluo.com/Team/note/1663026
2. https://github.com/SivilTaram/Graph-Neural-Network-Note
3. https://github.com/thunlp/GNNPapers